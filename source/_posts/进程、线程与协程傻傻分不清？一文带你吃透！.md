---
title: 进程、线程与协程傻傻分不清？一文带你吃透！
date: 2021-11-23 13:38:33
updated:
tags: OS
categories: 操作系统
keywords: 
description:
top_img:
comments:
cover:
toc:
toc_number:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
---

# 进程、线程与协程傻傻分不清？一文带你吃透！

## 前言

欢迎来到操作系统系列，依然采用图解 + 大白话的形式来讲解，让小白也能看懂，帮助大家快速科普入门。

本篇开始介绍进程、线程、协程，相信很多小白们对这几个概念理解的不清晰，这里全部给你们安排的明明白白，我们开始进入正文吧。

## 内容大纲

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231209791.png)

**小故事**

小明（操作系统）创办了一家互联网小公司，因为准备同时开发A与B两个软件，所以小明请了两个开发团队来做这件事情，分别是小王开发团队与小李开发团队，可是公司特别小，只有一个房间（CPU），而且房间（CPU）只能容纳一个开发团队，为了能两个软件开发不被耽误，小明（操作系统）决定，上午小王团队开发，下午小李团队开发（这个过程称为调度）。

小李（进程）与小王（进程）身为团队负责人，他们要操心的事情比较多，需要对软件进行分析整理，做架构设计，最后再把任务细化分配给团队的每个开发人员（线程），在团队交换房间的时候，还需要把整个软件开发进度记录下来，方便下次接着开发，相比开发人员就轻松多了，每个人只负责一小块，需要记录的也只有一小块。

通过这个小故事，大伙也看出来了，一个进程管理着多个线程，就像团队负责人（进程）管理着多个开发人员（线程）一样。

## 进程

### **什么是进程**

你打开网易云音乐会产生一个进程，你打开QQ会产生一个进程，你电脑上运行的程序都是进程，进程就是这么简单暴力。

现在我们思考一个问题，有一个进程读取硬盘里的文件，这个文件特别大，需要读取很长时间，如果 CPU 一直傻傻的等硬盘返回数据，那 CPU 的利用率是非常低的。

就像烧开水，你会傻傻等水烧开吗？很明显，这段时间完全可以去做其他的事情（比如玩玩赛博朋克2077），水烧开了再过来把水倒入水杯中，这样不香吗？

CPU 也是一样，它发现进程在读取硬盘文件，不需要阻塞等待硬盘返回数据，直接去执行其他进程，当硬盘返回数据时，CPU会收到中断的信号，于是 CPU 再回到之前的进程继续运行

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231212723.png)

这种多程序交替执行的方式，就是 CPU 管理多进程初步思想。

可能会有人问了，交替执行会不会很慢，这个不用担心，因为 CPU 的执行速度与切换速度非常的快，可能就是几十或几百毫秒，超出了人类的感知，一秒钟内可能就交替运行了多个进程，所以给我们产生并行的错觉，其实这叫并发。

单核多进程交替执行就是并发，多进程在多核运行就是并行。

### **进程的控制结构**

创造任何东西的时候，都要先有形，才有物，你造房子、造汽车或造其他东西，都要有设计图（结构），再根据设计图来创造，进程也不例外，它也有属于自己的设计图，那就是 进程控制块（process control block，PCB），后面就简称PCB好了

### PCB的结构信息

PCB是进程存在的唯一标识，这意味一个进程一定会有对应的PCB，进程消失，PCB也会随之消失

- 进程描述信息

- - 进程唯一的标记符，类似唯一id
  - 用户标识符，进程归属的用户，用户标识符主要为共享和保护服务

- 进程控制和管理信息

  - 进程当前状态，比如运行、就绪、阻塞等，作为处理机分配调度的依据
  - 进程优先级，描述进程抢占处理机的优先级，优先级高的进程可以优先获得处理机

- 资源分配清单

- - 用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入/输出设备信息

- CPU 相关信息

  - 指 CPU 中各寄存器值，当进程被切换时，CPU状态信息都必须保存在相应的PCB中，以便进程重新执行时，能再从断点继续执行。

### PCB组成的队列

PCB通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列

+ 将所有处于就绪状态的进程链在一起，称为就绪队列
+ 把所有因等待某事件而处于等待状态的进程链在一起就组成各种阻塞队列

<img src="https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231216214.png"  />

### **进程的状态**

通过观察，我们发现进程执行的过程遵循这样的运行-暂停-运行规律，虽然看起来十分简单，但是它的背后涉及到了进程状态的转换

#### **进程三态**

进程的执行期间，至少具备三种基本状态，即运行态、就绪态、阻塞态。

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231218035.png)

上图状态的意义

- 运行态（Runing）：时刻进程占用CPU
- 就绪态（Ready）：可运行，但因为其他进程正在运行而暂停停止
- 阻塞状态（Blocked）：该进程等待某个事件（比如IO读取）停止运行，这时，即使给它CPU控制权，它也无法运行

上图状态转换流程

1. CPU调度绪态进程执行，进入运行状态，时间片使用完了，回到就绪态，等待 CPU 调度
2. CPU调度绪态进程执行，进入运行状态，执行IO请求，进入阻塞态，IO请求完成，**CPU收到中断信号**，进入就绪态，等待 CPU 调度

#### **进程五态**

在三态基础上，做一次细化，出现了另外两个基本状态，创建态和结束态。

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231402314.png)

上图状态的意义

- 创建态（new）：进程正在被创建
- 就绪态（Ready）：可运行，但因为其他进程正在运行而暂停停止
- 运行态（Runing）：时刻进程占用 CPU
- 结束态（Exit）：进程正在从系统中消失时的状态
- 阻塞状态（Blocked）：该进程等待某个事件（比如IO读取）停止运行，这时，即使给它CPU控制权，它也无法运行

状态的变迁

- NULL => 创建态（new）：一个新进程被创建时的第一个状态
- 创建态（new） => 就绪态（Ready）：当进程创建完成，进入就绪态
- 就绪态（Ready）=>  运行态（Runing）：CPU 从就绪队列选择进程执行，进入运行态
- 运行态（Runing）=> 结束态（Exit）：当进程已经运行完成或出错时，进入结束状
- 运行态（Runing） => 就绪态（Ready）：分配给进程的时间片使用完，进入就绪态
- 运行态（Runing） => 阻塞状态（Blocked）：进程执行等待事件，进入阻塞态
- 阻塞状态（Blocked） => 就绪态（Ready）：进程事件完成，CPU 收到中断信号 ，进入就绪态

#### 进程七态

其实进程还有一种状态叫挂起态，挂起态代表该进程不会占用内存空间，它会被换出到硬盘空间保存，当需要使用它的时候，会被换入，加载到内存，挂起态可以分为下面两种

- 阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现
- 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行

结合上述的两种挂起态，就组成了进程七态

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231412769.png)

从上图我们发现，创建态、就绪态、运行态，阻塞挂起态、阻塞态都可以转入挂起态，这时问题就产生了，什么情况会转入 挂起态 ，什么情况又会从挂起态转入到非挂起态（就绪态与阻塞态）， 操作系统会根据当前资源状况和性能要求、进程的优先级来进行挂起与激活操作，没有固定的说法。

### **进程的上下文切换**

CPU把一个进程切换到另一个进程运行的过程，称为进程上下文切换。

**在说进程上下文切换之前，先来聊聊CPU上下文切换**

CPU上下文是指CPU寄存器和程序计数器

- CPU 寄存器 是CPU内置的容量小，速度极快的缓存
- 程序计数器是用来存储是 CPU 正在执行的指令位置或即将执行的下一条指令位置

CPU 上下文切换就很好理解了，就是把前一个任务的CPU上下文保存起来，然后在加载当前任务的 CPU上下文，最后再跳转到程序计数器所指的新位置，运行任务。

上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：进程上下文切换、线程上下文切换和中断上下文切换。

### 进程的上下文是怎么切换的

首先进程是由内核管理与调度的，所以进程上下文切换发生在内核态，进程上下文切换的内容包含用户空间资源（虚拟内存、栈、全局变量等）与内核空间资源（内核堆栈、寄存器等）。

在做上下文切换的时候，会把前一个进程的上下文保存到它的PCB中，然后加载当前进程的PCB上下文到 CPU 中，使得进程继续执行

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231417541.png)

发生进程上下文切换的场景

- 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，切换到其它正在等待 CPU 的进程运行
- 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。
- 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。
- 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行
- 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。

## 线程

### **什么是线程**

在早期操作系统都是以进程为独立运行的基本单位，直到后面，计算机科学家又提出了更小的能独立运行的基本单位，它就是线程。

在现代操作系统，进程是最小的资源分配单位，线程是最小的运行单位，一个进程下面能有一个或多个线程，每个线程都有独立一套的寄存器和栈，这样可以确保线程的控制流是相对独立的。

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231418883.png)

线程带来的好处有以下几点

- 一个进程中可以同时存在多个线程
- 让进程具备多任务并行处理能力
- 同进程下的各个线程之间可以共享进程资源 （同进程内的多线程通信十分简单高效）
- 更轻量与高效

线程带来的坏处有以下几点

- 因为进程资源共享，所以会产生资源竞争，需要通过锁机制来协同
- 当进程中的一个线程奔溃时，会导致其所属进程的所有线程奔溃（一般游戏的用户设计不会采用多线程方式）

### **线程与进程的对比**

- 进程是最小的资源（包括内存、打开的文件等）分配单位，线程是最小的运行单位
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系（和进程大同小异）
- 线程的创建、终止时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，所以线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们（线程管理的资源较少）
- 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的
- 由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了

线程比进程不管是时间效率，还是空间效率都要高

### **线程的上下文切换**

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231424534.png)

当进程只有一个线程时，可以认为进程等于线程，线程上下文的切换分两种情况

1. 不同进程的线程，切换的过程就跟进程上下文切换一样
2. 两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据

所以线程的上下文切换相比进程，开销要小很多

### **线程的模型**

在说线程模式之前，先介绍3个概念

- 内核线程：在内核空间就实现的线程，由内核管理
- 用户线程：在用户空间实现的线程，不归内核管理，是由用户态通过线程库完成线程的管理（用户态是指线程或进程在用户空间运行）
- 轻量级进程：在内核中来支持用户线程（用户线程与内核线程的中间层，内核线程的高度抽象）

### 内核线程

因为内核线程是由内核空间管理，所以它的 结构线程控制块（Thread Control Block, TCB）在内核空间，操作系统对TCB是可见的

内核线程

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231426929.png)

内核线程有什么优点

- 内核线程的由内核空间管理，线程的创建、销毁、调度等，都不用你操心，全自动化，属于智能型
- 内核线程能利用cpu多核的特性，实现并行执行（因为由内核管理，非常智能）
- 内核线程阻塞，不会影响其他内核线程（因为由内核管理，非常智能）

内核线程有什么缺点

- 因为是内核管理，所以内核线程的大部分操作都涉及到内核态，即需要从用户态切换到内核态，开销较大
- 因为内核资源有限，所以无法大量创建内核线程

### 用户线程

因为用户线程在用户空间，是由态通过线程库来管理，所以它的结构线程控制块（Thread Control Block, TCB）也是在线程库里面，对于操作系统而言是看不到TCB的，它只能看到整个进程的PCB（内核无法管理用户线程，也感知不到用户线程）

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231427159.png)

用户线程有什么优点

- 因为用户线程创建、销毁、调度等都不走内核态，直接在用户态进行操作，所以速度特别快
- 不依赖内核，可用于不支持线程技术的操作系统
- 可以大量创建用户线程，不消耗内核资源

用户线程有什么缺点

- 用户线程创建、销毁、调度等需要自己实现相应线程库
- 用户线程阻塞会导致整个进程内的其他用户线程阻塞（整个进程阻塞），因为内核感知不到用户线程，所以无法去调度其他用户线程
- 无法利用CPU多核特性，还是因为内核感知不到用户线程

### 轻量级进程（Light-weight process，LWP）

轻量级进程（Light-weight process，LWP）可以理解成内核线程的高级抽象，一个进程可以有一个或多个LWP，因为每个LWP与内核线程一对一映射，所以LWP都是由一个内核线程支持（用户线程关联LWP，即成为内核支持的用户线程）。

在大多数系统中，LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息。一般来说，一个进程代表程序的一个实例，而LWP代表程序的执行线程，因为一个执行线程不像进程那样需要那么多状态信息，所以LWP也不带有这样的信息。

### 一对一模型（内核级线程模型）

LWP就是一对一模型，即进程只需要创建使用LWP，因为一个LWP由一个内核线程支持，所以最终是内核管理线程，可以调度到其他处理器上（再简单点解释，直接使用内核线程）

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231432713.png)

一对一模型（1:1）的优缺点就不多说了，上面介绍内核线程的时候已经说过了，**但是值得一提的是，jvm采用该模型实现线程，所以在Java中启动一个线程需要谨慎**

### 一对多模型（用户级线程模型）

一对多模型，即多个用户级线程对用到同一个LWP上实现，因为是用户态通过用户空间的线程库对线程管理，所以速度特别快，不会涉及到用户态与内核态的转换

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231432385.png)

一对多模型（n:1）的优点缺点体现在用户级线程上面，**用户线程的优缺点前面说过，这里不做概述，值得一提的是 Python 中的协程就是通过该模型实现。**

### 多对多模型（两级线程模型）

多对多模型是集各家所长诞生的产物，它充分吸收前两种线程模型的优点且尽量避免它们的缺点。

首先它区别于多对一模型，多对多模型进程内的多用户线程可以绑定不同的内核线程，这点与一对一模型类似，其次又区别于一对一模型，进程内的多用户线程与内核线程不是一对一绑定，而是动态绑定，当某个内核线程因绑定的用户线程执行阻塞操作，让出 CPU 时，绑定该内核线程的其他用户线程可以解绑，重新绑定到其他内核线程继续运行。

所以多对多模型（m:n），即不是多对一模型完全靠自己实现的线程库调度，也不是一对一模型完全靠操作系统调度，而是一个中间态系统（负责自身调度与操作系统调度的协同工作），**最后提一句Go语言使用的是多对多模型，这也是其高并发的原因，它的线程模型与Java中的ForkJoinPool非常类似。**

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231433682.png)

多对多模型优点

- 兼具多对一模型的轻量
- 由于对应了多个内核线程，则一个用户线程阻塞时，其他用户线程仍然可以执行
- 由于对应了多个内核线程，则可以实现较完整的调度、优先级等；

多对多模型缺点

- 实现复杂（因为这种模型的高度复杂性，操作系统内核开发者一般不会使用，所以更多时候是作为第三方库的形式出现）

## 调度

### **调度原则**

#### CPU 利用率

- 运行程序发生了I/O 事件的请求，因此阻塞，导致进程在等待硬盘的数据返回。这样的过程，势必会造成 CPU 突然的空闲。所以为了提高 CPU 利用率，发生等待事件使 CPU 空闲的情况下，调度程序需要从就绪队列中选择一个进程来运行。（PS：调度程序应确保 CPU 一直保持匆忙的状态，可提高 CPU 的利用率）

#### 系统吞吐量

- 程序执行某个任务花费的时间会比较长，如果这个程序一直占用着 CPU，会造成系统吞吐量的降低。所以要提高系统的吞吐率，调度程序要权衡长任务和短任务进程的运行完成数量。（吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量）

#### 周转时间

- 从进程开始到结束的过程中，实际上是包含两个时间，分别是进程运行时间和进程等待时间，这两个时间总和就称为周转时间。进程的周转时间越小越好，如果进程的等待时间很长，而运行时间很短，那周转时间就很长，调度程序应该避免这种情况发生。（周转时间是进程运行和阻塞时间总和，一个进程的周转时间越小越好）

#### 等待时间

- 处于就绪队列的进程，也不能等太久，希望这个等待的时间越短越好，因为可以使进程更快的在 CPU 中执行。所以就绪队列中，进程的等待时间，也是调度程序所需要考虑的原则（这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待时间越长，用户越不满意）。

#### 响应时间

- 对于鼠标、键盘这种交互式比较强的应用，我们当然希望它的响应时间越快越好，否则就会影响用户体验了。所以，对于交互式比较强的应用，响应时间也是调度程序需要考虑的原则（用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准）。

### **调度算法**

不同的算法适用不同的场景，下面介绍几个单核中常见的调度算法

#### 先来先服务算法（First Come First Severd, FCFS）

先来先服务算法简称FCFS，顾名思义，谁先来，谁先被 CPU 执行，后到的就乖乖排队等待，十分简单的算法，CPU每次调度就绪队列的第一个进程，直到进程退出或阻塞，才会把该进程入队到队尾，然后接着继续调度第一个进程，依此类推。

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231438524.png)

FCFS算法看似很公平，但是当一个长作业先运行了，后面的短作业等待的时间就会很长，所以不利于短作业，会降低系统吞吐量。

FCFS对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。

#### 最短作业优先算法（Shortest Job First, SJF）

同样也是顾名思义，它会优先选择运行时间最短的进程，有助于提高系统吞吐量。但是对长作业不利，所以很容易造成一种极端现象。比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，最终使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行（适用于 I/O 繁忙型作业的系统）。

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231437165.png)

#### 高响应比优先算法 （Highest Response Ratio Next, HRRN）

因为前面的「先进先出算法」和「最短作业优先算法」都没有很好的权衡短作业和长作业，所以高响应比优先算法主要是权衡了短作业和长作业。

每次进行进程调度时，先计算「响应比优先权」，然后把「响应比优先权」最高的进程投入运行。

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231436921.png)

从上面的公式，可以发现：

如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「优先权」就越高，这样短作业的进程容易被选中运行（如果等待时间较短，进程的运行时间越短，优先权就会越高 => 等待时间较短的短作业进程）

如果两个进程「要求的服务时间」相同时，「等待时间」越长，「优先权」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会（如果要求服务时间比较长，进程的等待时间越长，优先权就会越高 => 等待时间较长的长作业进程）

#### 时间片轮转（Round Robin, RR）算法

时间片轮转是最古老、最简单、最公平且使用最广的算法，给每个进程分配相同时间片（Quantum），允许进程在该时间段中运行。

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231436788.png)

- 如果时间片用完，进程还在运行，将会把此进程放入就绪队列，并继续调度另外一个进程，依此类推
- 如果该进程在时间片结束前阻塞或结束，则调度另外一个进程
- 进程时间片用完，需要被重新分配时间片

需要注意的是，如果时间片设置的太短，会导致CPU上下文切换态频繁，太长又可能引起对短作业进程的响应时间变长，所以时间片设为 20ms~50ms 通常是一个比较合理的折中值

#### 最高优先级（Highest Priority First，HPF）算法

前面的「时间片轮转算法」让所有的进程同等重要，不偏袒谁，大家的运行时间都一样。但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，希望调度程序能从就绪队列中选择最高优先级的进程运行，这就是最高优先级（Highest Priority First，HPF）算法。

进程的优先级可以分为：

- 静态优先级：创建进程时候，已经确定优先级，整个运行时间优先级都不会变化
- 动态优先级：根据进程的动态变化调整优先级，比如进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则提高优先级。

有两种处理优先级高的方法：

- 非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。
- 抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。

但是依然有缺点，可能会导致低优先级的进程永远不会运行。

#### 多级反馈队列（Multilevel Feedback Queue）算法

多级反馈队列（Multilevel Feedback Queue）算法是基于「时间片轮转算法」和「最高优先级算法」演进而来，如同它的名字一样，根据优先级分组成多个队列，在算法中涉及两个概念：

- 「多级」表示有多个队列，每个队列优先级从高到低，优先级越高的队列拥有的时间片越短
- 「反馈」 表示有新的进程进入优先级高的队列时，停止当前运行进程，去运行优先级高的队列

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111231435705.png)

工作流程：

- 多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短
- 新进的进程会被放入第一级队列尾部，按先来先服务的原则排队等待被调度，如果第一级队列时间片用完，还有进程没有执行，把第一级队列剩余的进程放入第二级队列的尾部，依此类推
- 当优先级高队列为空，正在运行低优先级队列的进程时，有新进程进入高优先级队列，这时立即停止当前运行进程，把当前进程放入原队列尾部，转而去运行高优先级队列的进程。

可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，很好的兼顾了长短作业，同时有较好的响应时间。

> [link](https://mp.weixin.qq.com/s/jhOSjVyRA6rNKqVT2pKMIQ)























