---
title: 为什么浮点数不精确？
date: 2021-11-18 21:19:33
updated:
tags: 浮点数
categories:
- [计算机组成原理]
- [技术转载学习]
keywords: 
description:
top_img:
comments:
cover:
toc:
toc_number:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
---

# 为什么浮点数不精确？

### 计算机中的定点数和浮点数

计算机中数据有定点数和浮点数两种表达方式。

我们先来了解一下概念：

+ 定点数：小数点固定在某个位置上的数据。 就好像 0.0000001 ，0.0001111；

+ 浮点数：小数点位置可以浮动的数据。就像数学中的 `1222.2*10^3`也可以表示为`1.2222*10^6`；

提一下定点数的概念是主要是为了说明浮点数。

浮点数表达式：$N=M*R^E$

N为浮点数，M为尾数（mantissa），E也阶码（exponent），R为阶的基数，也就是底数啦，就像上面的10，不过咱们计算机里的底数不会是10的。

R通常是一个常数，一般是2、8、16。在一台计算机里，所有数据中的R是确定，且相同的。

浮点数在计算机内的形式：

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111182107547.png)

Ms是符号位，被设置到最高位上。

E是阶码，有n+1位，一般为整数，其中E的最高位是E的符号位，用来表示阶数E的正负；

M是尾数，有m位。Ms与M组成一个定点小数。

在学习过程中我们会遇到规格化，这里解释一下啥是规格化，唔，就是科学计数法那样的表示方式，就像上面的`1222.2*10^3`表示为`1.2222*10^6`差不多，不过我们规格化后，小数点左边为符号位，尾数的其余部分都在小数点右边；这里我们应该就知道了规格化并不会影响浮点数的值。

Ms 是符号位，非0即1，所以只占一位。

E 为n+1，其实的1就是E的符号位，n是E的尾数。

M的是m，就是除了符号位的尾数占的部分。

比如单精度浮点数（32位），阶码8位，尾数那就是24位咯（尾数中内含一位符号位Ms为什么浮点数不精确？）；

比如双精度浮点数（64位），阶码11位，尾数那就是53位（一样）。

当一个浮点数的尾数是0了咋办，什么咋办，计算机当然看成0啦；

阶码的值超级小，小到机器能表示的最小值（我没遇到过），计算机也是当成0的，以上两种成为机器零。

IEEE 754 国际标准规定了，基数为2，阶码采用移码，尾数采用原码。因为规格化原码的最高位恒为1，所以不在尾数中表示出来，计算时候再尾数的前面自动添加1。

### 为什么浮点数不精确？

很多人都知道，Java 中的浮点数并不精确，需要用 BigDecimal 进行精确计算，但是，很少有人知道为什么浮点数不精确呢？不精确为什么还要用呢？本文就来展开分析一波；

我们知道，计算机的数字的存储和运算都是通过二进制进行的，对于，十进制整数转换为二进制整数采用”**除2取余，逆序排列**”法。

具体做法是：

- 用2整除十进制整数，可以得到一个商和余数；
- 再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止
- 然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。

如，我们想要把127转换成二进制，做法如下：

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111182016519.jpeg)

那么，十进制小数转换成二进制小数，又该如何计算呢？

十进制小数转换成二进制小数采用”**乘2取整，顺序排列**”法。

具体做法是：

- 用2乘十进制小数，可以得到积
- 将积的整数部分取出，再用2乘余下的小数部分，又得到一个积
- 再将积的整数部分取出，如此进行，直到积中的小数部分为零，此时0或1为二进制的最后一位。或者达到所要求的精度为止。

如尝试将0.625转成二进制：

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111182018226.jpeg)

但是0.625是一个特例，用同样的算法，请计算下0.1对应的二进制是多少：

![](https://cdn.jsdelivr.net/gh/mbfjllybl/pictures-bed/202111182018880.jpeg)

我们发现，0.1的二进制表示中出现了无限循环的情况，也就是(0.1)10 = (0.000110011001100…)2

这种情况，计算机就没办法用二进制精确的表示0.1了。

所以，为了解决部分小数无法使用二进制精确表示的问题，于是就有了IEEE 754规范。

IEEE二进制浮点数算术标准（IEEE 754）是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。

> 浮点数和小数并不是完全一样的，计算机中小数的表示法，其实有定点和浮点两种。因为在位数相同的情况下，定点数的表示范围要比浮点数小。所以在计算机科学中，使用浮点数来表示实数的近似值。

IEEE 754规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。

其中最常用的就是32位单精度浮点数和64位双精度浮点数。

> 单精度浮点数在计算机存储器中占用4个字节（32 bits），利用“浮点”（浮动小数点）的方法，可以表示一个范围很大的数值。
>
> 比起单精度浮点数，双精度浮点数(double)使用 64 位（8字节） 来存储一个浮点数。

IEEE并没有解决小数无法精确表示的问题，只是提出了一种使用近似值表示小数的方式，并且引入了精度的概念。

一个浮点数a由两个数m和e来表示：$a = m * b^e$。

在任意一个这样的系统中，我们选择一个基数b（记数系统的基）和精度p（即使用多少位来存储）。m（即尾数）是形如`±d.ddd…ddd`的p位数（每一位是一个介于0到b-1之间的整数，包括0和b-1)。

如果m的第一位是非0整数,m称作规格化的。有一些描述使用一个单独的符号位(s 代表+或者-）来表示正负，这样m必须是正的。e是指数。

最后，由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。

建议使用BigDecimal或者Long（单位为分）来表示金额。

> [link](https://www.hollischuang.com/archives/6644)        
>
> [link](https://blog.csdn.net/whoisleft/article/details/77417541?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link)

